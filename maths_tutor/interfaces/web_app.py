"""
Web Interface - FastAPI-based web application for the CBSE Tutor.

Provides:
- A book-selection landing page + scoped chat UI served at GET /
- REST API endpoints for ask, quiz, practice, explain, stats
- Server-Sent Events (SSE) streaming for real-time answers
- Per-book RAG pipelines with tailored system prompts

Run with:
    uvicorn maths_tutor.interfaces.web_app:app --reload
"""

import asyncio
import json
from collections.abc import AsyncGenerator
from pathlib import Path

from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import HTMLResponse, StreamingResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel, Field

from maths_tutor.config import (
    BOOKS_MANIFEST_PATH,
    COLLECTION_PREFIX,
    RAG_PROMPT_TEMPLATE,
    SYSTEM_PROMPT,
    get_subject_system_prompt,
)

# ---------------------------------------------------------------------------
# Pydantic request/response models
# ---------------------------------------------------------------------------


class ChatMessage(BaseModel):
    role: str = Field(..., pattern="^(user|assistant)$")
    content: str = Field(..., max_length=4000)


class AskRequest(BaseModel):
    question: str = Field(..., min_length=1, max_length=2000)
    book_id: str = Field(..., min_length=1, max_length=100)
    stream: bool = Field(default=True)
    history: list[ChatMessage] = Field(
        default_factory=list,
        description="Recent conversation turns for follow-up context",
    )


class QuizRequest(BaseModel):
    topic: str = Field(..., min_length=1, max_length=200)
    book_id: str = Field(..., min_length=1, max_length=100)
    num_questions: int = Field(default=5, ge=1, le=20)


class PracticeRequest(BaseModel):
    topic: str = Field(..., min_length=1, max_length=200)
    book_id: str = Field(..., min_length=1, max_length=100)
    num_problems: int = Field(default=3, ge=1, le=10)


class ExplainRequest(BaseModel):
    concept: str = Field(..., min_length=1, max_length=200)
    book_id: str = Field(..., min_length=1, max_length=100)


class AskResponse(BaseModel):
    answer: str
    sources: list[dict] = []
    num_chunks: int = 0


class StatsResponse(BaseModel):
    collection_name: str
    document_count: int
    unique_sources: list[str]


# ---------------------------------------------------------------------------
# App factory
# ---------------------------------------------------------------------------

TEMPLATES_DIR = Path(__file__).parent / "templates"
STATIC_DIR = Path(__file__).parent / "static"


def _load_books_manifest() -> dict:
    """Load the books.json manifest generated by ingestion."""
    if BOOKS_MANIFEST_PATH.exists():
        return json.loads(BOOKS_MANIFEST_PATH.read_text())
    return {"books": []}


def _find_book(manifest: dict, book_id: str) -> dict | None:
    """Find a book entry in the manifest by id."""
    for book in manifest.get("books", []):
        if book["id"] == book_id:
            return book
    return None


def create_app() -> FastAPI:
    """Create and configure the FastAPI application."""

    application = FastAPI(
        title="CBSE AI Tutor",
        description="RAG-powered tutor for CBSE Grade 5 curriculum with per-book agents",
        version="0.3.0",
    )

    templates = Jinja2Templates(directory=str(TEMPLATES_DIR))

    # Mount static files directory
    application.mount(
        "/static",
        StaticFiles(directory=str(STATIC_DIR)),
        name="static",
    )

    # Lazy-loaded singletons keyed by book_id
    _state: dict = {}

    # Cache the books manifest (reloaded on first request)
    def _get_manifest() -> dict:
        if "manifest" not in _state:
            _state["manifest"] = _load_books_manifest()
        return _state["manifest"]

    def _get_rag(book_id: str):
        """Return a RAGPipeline scoped to the given book."""
        key = f"rag_{book_id}"
        if key not in _state:
            from maths_tutor.rag.generator import RAGPipeline

            manifest = _get_manifest()
            book = _find_book(manifest, book_id)

            collection_name = f"{COLLECTION_PREFIX}{book_id}"
            if book:
                system_prompt = get_subject_system_prompt(
                    book_id=book_id,
                    book_title=book.get("title", ""),
                    chapter_label=book.get("chapter_label", "chapter"),
                    chapters=book.get("chapters", []),
                    units=book.get("units", []),
                )
            else:
                system_prompt = SYSTEM_PROMPT

            _state[key] = RAGPipeline(
                collection_name=collection_name,
                system_prompt=system_prompt,
            )
        return _state[key]

    def _get_vector_store(book_id: str | None = None):
        """Return a VectorStore for a given book (or first available)."""
        vs_key = f"vs_{book_id}" if book_id else "vs_default"
        if vs_key not in _state:
            from maths_tutor.embeddings.vector_store import VectorStore

            if book_id:
                collection_name = f"{COLLECTION_PREFIX}{book_id}"
            else:
                # Fallback: use first book from manifest
                manifest = _get_manifest()
                books = manifest.get("books", [])
                if books:
                    collection_name = books[0]["collection_name"]
                else:
                    collection_name = None
            kwargs = {"collection_name": collection_name} if collection_name else {}
            _state[vs_key] = VectorStore(**kwargs)
        return _state[vs_key]

    def _validate_book_id(book_id: str) -> dict:
        """Validate book_id exists in manifest; raise 404 if not."""
        manifest = _get_manifest()
        book = _find_book(manifest, book_id)
        if not book:
            valid_ids = [b["id"] for b in manifest.get("books", [])]
            raise HTTPException(
                status_code=404,
                detail=f"Book '{book_id}' not found. Available: {valid_ids}",
            )
        return book

    # ------------------------------------------------------------------
    # Pages
    # ------------------------------------------------------------------

    @application.get("/", response_class=HTMLResponse)
    async def index(request: Request):
        """Serve the book selection + chat UI."""
        return templates.TemplateResponse(request, "index.html", {})

    # ------------------------------------------------------------------
    # Health
    # ------------------------------------------------------------------

    @application.get("/health")
    async def health():
        manifest = _get_manifest()
        total_chunks = sum(b.get("chunk_count", 0) for b in manifest.get("books", []))
        return {
            "status": "ok",
            "books_count": len(manifest.get("books", [])),
            "total_chunks": total_chunks,
        }

    # ------------------------------------------------------------------
    # Books API
    # ------------------------------------------------------------------

    @application.get("/api/books")
    async def list_books():
        """Return the books manifest with metadata and chapter lists."""
        manifest = _get_manifest()
        return manifest

    # ------------------------------------------------------------------
    # Ask endpoints
    # ------------------------------------------------------------------

    @application.post("/api/ask", response_model=AskResponse)
    async def ask(body: AskRequest):
        """Answer a student question (non-streaming, scoped to a book)."""
        _validate_book_id(body.book_id)
        rag = _get_rag(body.book_id)
        result = rag.query(body.question, stream=False, include_sources=True)
        return AskResponse(
            answer=result["answer"],
            sources=result["sources"],
            num_chunks=result["num_chunks"],
        )

    @application.post("/api/ask/stream")
    async def ask_stream(body: AskRequest):
        """Stream an answer as Server-Sent Events, scoped to a book."""
        _validate_book_id(body.book_id)
        rag = _get_rag(body.book_id)

        async def _event_generator() -> AsyncGenerator[str, None]:
            retrieval_query = body.question
            if body.history:
                recent = body.history[-4:]
                context_lines = [
                    f"{m.role}: {m.content}" for m in recent
                ]
                retrieval_query = (
                    "\n".join(context_lines)
                    + f"\nuser: {body.question}"
                )

            retrieval = rag.retriever.retrieve(retrieval_query)
            context = retrieval.format_for_prompt()

            import ollama as _ollama

            messages: list[dict[str, str]] = [
                {"role": "system", "content": rag.generator.system_prompt},
            ]
            for msg in (body.history or [])[-6:]:
                messages.append({"role": msg.role, "content": msg.content})

            user_prompt = RAG_PROMPT_TEMPLATE.format(
                context=context, question=body.question,
            )
            messages.append({"role": "user", "content": user_prompt})

            stream = _ollama.chat(
                model=rag.generator.model,
                messages=messages,
                stream=True,
            )
            for chunk in stream:
                if "message" in chunk and "content" in chunk["message"]:
                    token = chunk["message"]["content"]
                    payload = json.dumps({"token": token})
                    yield f"data: {payload}\n\n"
                    await asyncio.sleep(0)

            sources_payload = json.dumps({
                "done": True,
                "sources": retrieval.sources,
                "num_chunks": len(retrieval.chunks),
            })
            yield f"data: {sources_payload}\n\n"

        return StreamingResponse(
            _event_generator(),
            media_type="text/event-stream",
        )

    # ------------------------------------------------------------------
    # Quiz / Practice / Explain
    # ------------------------------------------------------------------

    @application.post("/api/quiz")
    async def quiz(body: QuizRequest):
        """Generate a quiz on a topic, scoped to a book."""
        _validate_book_id(body.book_id)
        rag = _get_rag(body.book_id)
        result = await asyncio.to_thread(
            rag.quiz, body.topic, body.num_questions
        )
        return {"quiz": result}

    @application.post("/api/practice")
    async def practice(body: PracticeRequest):
        """Generate practice problems, scoped to a book."""
        _validate_book_id(body.book_id)
        rag = _get_rag(body.book_id)
        result = await asyncio.to_thread(
            rag.practice, body.topic, body.num_problems
        )
        return {"practice": result}

    @application.post("/api/explain")
    async def explain(body: ExplainRequest):
        """Explain a concept, scoped to a book."""
        _validate_book_id(body.book_id)
        rag = _get_rag(body.book_id)
        result = await asyncio.to_thread(rag.explain, body.concept)
        return {"explanation": result}

    # ------------------------------------------------------------------
    # Stats
    # ------------------------------------------------------------------

    @application.get("/api/stats", response_model=StatsResponse)
    async def stats(book_id: str | None = None):
        """Return vector store statistics for a book (or first available)."""
        vs = _get_vector_store(book_id)
        s = vs.get_stats()
        return StatsResponse(
            collection_name=s["collection_name"],
            document_count=s["document_count"],
            unique_sources=s["unique_sources"],
        )

    return application


# Module-level app instance (used by ``uvicorn maths_tutor.interfaces.web_app:app``)
app = create_app()
